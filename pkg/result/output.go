package result

import (
	"encoding/json"
	"fmt"
	"io"
	"strings"

	"github.com/oisee/z80-optimizer/pkg/inst"
)

// JSONRule is the JSON-serializable form of a Rule.
type JSONRule struct {
	SourceASM      string `json:"source_asm"`
	ReplacementASM string `json:"replacement_asm"`
	SourceBytes    int    `json:"source_bytes"`
	ReplacementBytes int  `json:"replacement_bytes"`
	BytesSaved     int    `json:"bytes_saved"`
	CyclesSaved    int    `json:"cycles_saved"`
}

// WriteJSON writes rules as JSON to the writer.
func WriteJSON(w io.Writer, rules []Rule) error {
	jsonRules := make([]JSONRule, len(rules))
	for i, r := range rules {
		jsonRules[i] = JSONRule{
			SourceASM:        disasmSeq(r.Source),
			ReplacementASM:   disasmSeq(r.Replacement),
			SourceBytes:      inst.SeqByteSize(r.Source),
			ReplacementBytes: inst.SeqByteSize(r.Replacement),
			BytesSaved:       r.BytesSaved,
			CyclesSaved:      r.CyclesSaved,
		}
	}
	enc := json.NewEncoder(w)
	enc.SetIndent("", "  ")
	return enc.Encode(jsonRules)
}

// ReadJSON reads rules from JSON.
func ReadJSON(r io.Reader) ([]JSONRule, error) {
	var rules []JSONRule
	if err := json.NewDecoder(r).Decode(&rules); err != nil {
		return nil, err
	}
	return rules, nil
}

// WriteGoCode generates Go peephole pattern code compatible with MinZ.
func WriteGoCode(w io.Writer, rules []Rule) error {
	fmt.Fprintln(w, "// Code generated by z80opt. DO NOT EDIT.")
	fmt.Fprintln(w, "")
	fmt.Fprintln(w, "package optimizer")
	fmt.Fprintln(w, "")
	fmt.Fprintln(w, "// Z80OptRules contains peephole optimization rules discovered by the superoptimizer.")
	fmt.Fprintln(w, "var Z80OptRules = []PeepholeRule{")

	for _, r := range rules {
		srcAsm := disasmSeq(r.Source)
		replAsm := disasmSeq(r.Replacement)
		fmt.Fprintf(w, "\t// %s -> %s (-%d bytes, -%d cycles)\n",
			srcAsm, replAsm, r.BytesSaved, r.CyclesSaved)
		fmt.Fprintf(w, "\t{\n")
		fmt.Fprintf(w, "\t\tMatch: []string{%s},\n", goStringSlice(r.Source))
		fmt.Fprintf(w, "\t\tReplace: []string{%s},\n", goStringSlice(r.Replacement))
		fmt.Fprintf(w, "\t},\n")
	}

	fmt.Fprintln(w, "}")
	return nil
}

func disasmSeq(seq []inst.Instruction) string {
	parts := make([]string, len(seq))
	for i, instr := range seq {
		parts[i] = inst.Disassemble(instr)
	}
	return strings.Join(parts, " : ")
}

func goStringSlice(seq []inst.Instruction) string {
	parts := make([]string, len(seq))
	for i, instr := range seq {
		parts[i] = fmt.Sprintf("%q", inst.Disassemble(instr))
	}
	return strings.Join(parts, ", ")
}
